// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: plan_assignment.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignPlan = `-- name: AssignPlan :one
insert into plan_assignment (
    plan_id,
    organization_id,
    user_id,
    valid_from,
    valid_until,
    created_by,
    updated_by
) values (
$1, $2, $3, $4, $5, $6, $7
) returning id, plan_id, organization_id, user_id, valid_from, valid_until, created_at, updated_at, created_by, updated_by
`

type AssignPlanParams struct {
	PlanID         pgtype.UUID
	OrganizationID pgtype.Text
	UserID         pgtype.Text
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	CreatedBy      string
	UpdatedBy      string
}

// assigns a plan to either an organization or a user based on which id is provided
func (q *Queries) AssignPlan(ctx context.Context, arg AssignPlanParams) (PlanAssignment, error) {
	row := q.db.QueryRow(ctx, assignPlan,
		arg.PlanID,
		arg.OrganizationID,
		arg.UserID,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i PlanAssignment
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.OrganizationID,
		&i.UserID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const countAllAssignments = `-- name: CountAllAssignments :one
SELECT count(pa.*)
FROM plan_assignment pa
INNER JOIN plan p ON pa.plan_id = p.id
WHERE p.tenant_slug = $1
AND p.archived_at IS NULL
`

func (q *Queries) CountAllAssignments(ctx context.Context, tenantSlug string) (int64, error) {
	row := q.db.QueryRow(ctx, countAllAssignments, tenantSlug)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAssignments = `-- name: CountAssignments :one
SELECT count(*)
FROM plan_assignment
WHERE (
    (organization_id = $1 or $1 is null) and 
    (user_id = $2 or $2 is null)
)
AND (plan_id = $3 or $3 is null)
AND (valid_from >= $4 or $4 is null)
AND (valid_until <= $5 or $5 is null)
AND EXISTS (SELECT 1 FROM plan where id = plan_id and tenant_slug = $6)
`

type CountAssignmentsParams struct {
	OrganizationID pgtype.Text
	UserID         pgtype.Text
	PlanID         pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	TenantSlug     string
}

func (q *Queries) CountAssignments(ctx context.Context, arg CountAssignmentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAssignments,
		arg.OrganizationID,
		arg.UserID,
		arg.PlanID,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.TenantSlug,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAssignmentsHistory = `-- name: CountAssignmentsHistory :one
SELECT count(*)
FROM plan_assignment_history
WHERE (
    (organization_id = $1 or $1 is null) and
    (user_id = $2 or $2 is null)
)
AND (plan_id = $3 or $3 is null)
AND (valid_from < $4 or $4 is null)
AND (valid_from >= $5 or $5 is null)
AND (valid_until < $6 or $6 is null)
AND (valid_until >= $7 or $7 is null)
AND (action = $8 or $8 is null)
`

type CountAssignmentsHistoryParams struct {
	OrganizationID pgtype.Text
	UserID         pgtype.Text
	PlanID         pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidFrom_2    pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	ValidUntil_2   pgtype.Timestamptz
	Action         pgtype.Text
}

func (q *Queries) CountAssignmentsHistory(ctx context.Context, arg CountAssignmentsHistoryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAssignmentsHistory,
		arg.OrganizationID,
		arg.UserID,
		arg.PlanID,
		arg.ValidFrom,
		arg.ValidFrom_2,
		arg.ValidUntil,
		arg.ValidUntil_2,
		arg.Action,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listAllAssignmentsPaginated = `-- name: ListAllAssignmentsPaginated :many
SELECT
    pa.id,
    pa.plan_id,
    pa.organization_id,
    pa.user_id,
    pa.valid_from,
    pa.valid_until,
    pa.created_at,
    pa.updated_at,
    pa.created_by,
    pa.updated_by
FROM plan_assignment pa
INNER JOIN plan p ON pa.plan_id = p.id
WHERE p.tenant_slug = $1
AND p.archived_at IS NULL
ORDER BY pa.created_at DESC
LIMIT $2
OFFSET $3
`

type ListAllAssignmentsPaginatedParams struct {
	TenantSlug string
	Limit      int32
	Offset     int32
}

func (q *Queries) ListAllAssignmentsPaginated(ctx context.Context, arg ListAllAssignmentsPaginatedParams) ([]PlanAssignment, error) {
	rows, err := q.db.Query(ctx, listAllAssignmentsPaginated, arg.TenantSlug, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlanAssignment
	for rows.Next() {
		var i PlanAssignment
		if err := rows.Scan(
			&i.ID,
			&i.PlanID,
			&i.OrganizationID,
			&i.UserID,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssignmentsHistoryPaginated = `-- name: ListAssignmentsHistoryPaginated :many
SELECT id, action, plan_id, organization_id, user_id, valid_from, valid_until, created_at, updated_at, created_by, updated_by
FROM plan_assignment_history
WHERE (
    (organization_id = $1 or $1 is null) and
    (user_id = $2 or $2 is null)
)
AND (plan_id = $3 or $3 is null)
AND (valid_from < $4 or $4 is null)
AND (valid_from >= $5 or $5 is null)
AND (valid_until < $6 or $6 is null)
AND (valid_until >= $7 or $7 is null)
AND (action = $10 or $10 is null)
ORDER BY created_at DESC
LIMIT $8
OFFSET $9
`

type ListAssignmentsHistoryPaginatedParams struct {
	OrganizationID pgtype.Text
	UserID         pgtype.Text
	PlanID         pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidFrom_2    pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	ValidUntil_2   pgtype.Timestamptz
	Limit          int32
	Offset         int32
	Action         pgtype.Text
}

func (q *Queries) ListAssignmentsHistoryPaginated(ctx context.Context, arg ListAssignmentsHistoryPaginatedParams) ([]PlanAssignmentHistory, error) {
	rows, err := q.db.Query(ctx, listAssignmentsHistoryPaginated,
		arg.OrganizationID,
		arg.UserID,
		arg.PlanID,
		arg.ValidFrom,
		arg.ValidFrom_2,
		arg.ValidUntil,
		arg.ValidUntil_2,
		arg.Limit,
		arg.Offset,
		arg.Action,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlanAssignmentHistory
	for rows.Next() {
		var i PlanAssignmentHistory
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.PlanID,
			&i.OrganizationID,
			&i.UserID,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssignmentsPaginated = `-- name: ListAssignmentsPaginated :many
SELECT id, plan_id, organization_id, user_id, valid_from, valid_until, created_at, updated_at, created_by, updated_by
FROM plan_assignment
WHERE (
    (organization_id = $1 or $1 is null) and
    (user_id = $2 or $2 is null)
)
AND (plan_id = $7 or $7 is null)
AND (valid_from >= $5 or $5 is null)
AND (valid_until <= $6 or $6 is null)
AND EXISTS (SELECT 1 FROM plan where id = plan_id and tenant_slug = $8)
ORDER BY created_at DESC
LIMIT $3
OFFSET $4
`

type ListAssignmentsPaginatedParams struct {
	OrganizationID pgtype.Text
	UserID         pgtype.Text
	Limit          int32
	Offset         int32
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	PlanID         pgtype.UUID
	TenantSlug     string
}

func (q *Queries) ListAssignmentsPaginated(ctx context.Context, arg ListAssignmentsPaginatedParams) ([]PlanAssignment, error) {
	rows, err := q.db.Query(ctx, listAssignmentsPaginated,
		arg.OrganizationID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.PlanID,
		arg.TenantSlug,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlanAssignment
	for rows.Next() {
		var i PlanAssignment
		if err := rows.Scan(
			&i.ID,
			&i.PlanID,
			&i.OrganizationID,
			&i.UserID,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const terminateAssignedPlan = `-- name: TerminateAssignedPlan :exec
delete from plan_assignment
where plan_id = $1
and (
    (organization_id = $2 or $2 is null) and 
    (user_id = $3 or $3 is null)
)
`

type TerminateAssignedPlanParams struct {
	PlanID         pgtype.UUID
	OrganizationID pgtype.Text
	UserID         pgtype.Text
}

// removes a plan assignment for either an organization or user
func (q *Queries) TerminateAssignedPlan(ctx context.Context, arg TerminateAssignedPlanParams) error {
	_, err := q.db.Exec(ctx, terminateAssignedPlan, arg.PlanID, arg.OrganizationID, arg.UserID)
	return err
}

const updateAssignedPlan = `-- name: UpdateAssignedPlan :one
update plan_assignment
set valid_until = coalesce($5, valid_until),
    valid_from = coalesce($6, valid_from),
    updated_by = $2
where (plan_id = $1)
and (
    (organization_id = $3 or $3 is null) and
    (user_id = $4 or $4 is null)
)
returning id, plan_id, organization_id, user_id, valid_from, valid_until, created_at, updated_at, created_by, updated_by
`

type UpdateAssignedPlanParams struct {
	PlanID         pgtype.UUID
	UpdatedBy      string
	OrganizationID pgtype.Text
	UserID         pgtype.Text
	ValidUntil     pgtype.Timestamptz
	ValidFrom      pgtype.Timestamptz
}

// updates the validity period of a plan assignment for either organization or user
func (q *Queries) UpdateAssignedPlan(ctx context.Context, arg UpdateAssignedPlanParams) (PlanAssignment, error) {
	row := q.db.QueryRow(ctx, updateAssignedPlan,
		arg.PlanID,
		arg.UpdatedBy,
		arg.OrganizationID,
		arg.UserID,
		arg.ValidUntil,
		arg.ValidFrom,
	)
	var i PlanAssignment
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.OrganizationID,
		&i.UserID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: plan_assignment.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignPlanToOrg = `-- name: AssignPlanToOrg :one
INSERT INTO plan_assignment (
    plan_id,
    organization_id,
    valid_from,
    valid_until,
    created_by,
    updated_by
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, plan_id, organization_id, user_id, valid_from, valid_until, created_at, updated_at, created_by, updated_by
`

type AssignPlanToOrgParams struct {
	PlanID         pgtype.UUID
	OrganizationID pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	CreatedBy      string
	UpdatedBy      string
}

func (q *Queries) AssignPlanToOrg(ctx context.Context, arg AssignPlanToOrgParams) (PlanAssignment, error) {
	row := q.db.QueryRow(ctx, assignPlanToOrg,
		arg.PlanID,
		arg.OrganizationID,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i PlanAssignment
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.OrganizationID,
		&i.UserID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const assignPlanToUser = `-- name: AssignPlanToUser :one
INSERT INTO plan_assignment (
    plan_id,
    user_id,
    valid_from,
    valid_until,
    created_by,
    updated_by
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, plan_id, organization_id, user_id, valid_from, valid_until, created_at, updated_at, created_by, updated_by
`

type AssignPlanToUserParams struct {
	PlanID     pgtype.UUID
	UserID     pgtype.UUID
	ValidFrom  pgtype.Timestamptz
	ValidUntil pgtype.Timestamptz
	CreatedBy  string
	UpdatedBy  string
}

func (q *Queries) AssignPlanToUser(ctx context.Context, arg AssignPlanToUserParams) (PlanAssignment, error) {
	row := q.db.QueryRow(ctx, assignPlanToUser,
		arg.PlanID,
		arg.UserID,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i PlanAssignment
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.OrganizationID,
		&i.UserID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const unAssignPlanToOrg = `-- name: UnAssignPlanToOrg :exec
DELETE FROM plan_assignment
WHERE plan_id = $1
AND organization_id = $2
`

type UnAssignPlanToOrgParams struct {
	PlanID         pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) UnAssignPlanToOrg(ctx context.Context, arg UnAssignPlanToOrgParams) error {
	_, err := q.db.Exec(ctx, unAssignPlanToOrg, arg.PlanID, arg.OrganizationID)
	return err
}

const unAssignPlanToUser = `-- name: UnAssignPlanToUser :exec
DELETE FROM plan_assignment
WHERE plan_id = $1
AND user_id = $2
`

type UnAssignPlanToUserParams struct {
	PlanID pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) UnAssignPlanToUser(ctx context.Context, arg UnAssignPlanToUserParams) error {
	_, err := q.db.Exec(ctx, unAssignPlanToUser, arg.PlanID, arg.UserID)
	return err
}

const updateOrgsValidFromAndUntil = `-- name: UpdateOrgsValidFromAndUntil :one
UPDATE plan_assignment
SET valid_until = $5,
    valid_from = $4,
    updated_by = $3
WHERE plan_id = $1
AND organization_id = $2
RETURNING id, plan_id, organization_id, user_id, valid_from, valid_until, created_at, updated_at, created_by, updated_by
`

type UpdateOrgsValidFromAndUntilParams struct {
	PlanID         pgtype.UUID
	OrganizationID pgtype.UUID
	UpdatedBy      string
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
}

func (q *Queries) UpdateOrgsValidFromAndUntil(ctx context.Context, arg UpdateOrgsValidFromAndUntilParams) (PlanAssignment, error) {
	row := q.db.QueryRow(ctx, updateOrgsValidFromAndUntil,
		arg.PlanID,
		arg.OrganizationID,
		arg.UpdatedBy,
		arg.ValidFrom,
		arg.ValidUntil,
	)
	var i PlanAssignment
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.OrganizationID,
		&i.UserID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const updateUsersValidFromAndUntil = `-- name: UpdateUsersValidFromAndUntil :one
UPDATE plan_assignment
SET valid_until = $5,
    valid_from = $4,
    updated_by = $3
WHERE plan_id = $1
AND user_id = $2
RETURNING id, plan_id, organization_id, user_id, valid_from, valid_until, created_at, updated_at, created_by, updated_by
`

type UpdateUsersValidFromAndUntilParams struct {
	PlanID     pgtype.UUID
	UserID     pgtype.UUID
	UpdatedBy  string
	ValidFrom  pgtype.Timestamptz
	ValidUntil pgtype.Timestamptz
}

func (q *Queries) UpdateUsersValidFromAndUntil(ctx context.Context, arg UpdateUsersValidFromAndUntilParams) (PlanAssignment, error) {
	row := q.db.QueryRow(ctx, updateUsersValidFromAndUntil,
		arg.PlanID,
		arg.UserID,
		arg.UpdatedBy,
		arg.ValidFrom,
		arg.ValidUntil,
	)
	var i PlanAssignment
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.OrganizationID,
		&i.UserID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

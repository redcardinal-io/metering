// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: plan_assignment.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignPlanToOrg = `-- name: AssignPlanToOrg :one
INSERT INTO plan_assignment (
    plan_id,
    organization_id,
    valid_from,
    valid_until,
    created_by,
    updated_by
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, plan_id, organization_id, user_id, valid_from, valid_until, created_at, updated_at, created_by, updated_by
`

type AssignPlanToOrgParams struct {
	PlanID         pgtype.UUID
	OrganizationID pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	CreatedBy      string
	UpdatedBy      string
}

func (q *Queries) AssignPlanToOrg(ctx context.Context, arg AssignPlanToOrgParams) (PlanAssignment, error) {
	row := q.db.QueryRow(ctx, assignPlanToOrg,
		arg.PlanID,
		arg.OrganizationID,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i PlanAssignment
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.OrganizationID,
		&i.UserID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const assignPlanToUser = `-- name: AssignPlanToUser :one
INSERT INTO plan_assignment (
    plan_id,
    user_id,
    valid_from,
    valid_until,
    created_by,
    updated_by
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, plan_id, organization_id, user_id, valid_from, valid_until, created_at, updated_at, created_by, updated_by
`

type AssignPlanToUserParams struct {
	PlanID     pgtype.UUID
	UserID     pgtype.UUID
	ValidFrom  pgtype.Timestamptz
	ValidUntil pgtype.Timestamptz
	CreatedBy  string
	UpdatedBy  string
}

func (q *Queries) AssignPlanToUser(ctx context.Context, arg AssignPlanToUserParams) (PlanAssignment, error) {
	row := q.db.QueryRow(ctx, assignPlanToUser,
		arg.PlanID,
		arg.UserID,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i PlanAssignment
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.OrganizationID,
		&i.UserID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const unAssignPlanToOrgByPlanId = `-- name: UnAssignPlanToOrgByPlanId :exec
DELETE FROM plan_assignment
WHERE plan_id = $1
AND organization_id = $2
`

type UnAssignPlanToOrgByPlanIdParams struct {
	PlanID         pgtype.UUID
	OrganizationID pgtype.UUID
}

func (q *Queries) UnAssignPlanToOrgByPlanId(ctx context.Context, arg UnAssignPlanToOrgByPlanIdParams) error {
	_, err := q.db.Exec(ctx, unAssignPlanToOrgByPlanId, arg.PlanID, arg.OrganizationID)
	return err
}

const unAssignPlanToUserByPlanId = `-- name: UnAssignPlanToUserByPlanId :exec
DELETE FROM plan_assignment
WHERE plan_id = $1
AND user_id = $2
`

type UnAssignPlanToUserByPlanIdParams struct {
	PlanID pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) UnAssignPlanToUserByPlanId(ctx context.Context, arg UnAssignPlanToUserByPlanIdParams) error {
	_, err := q.db.Exec(ctx, unAssignPlanToUserByPlanId, arg.PlanID, arg.UserID)
	return err
}

const updateOrgsValidFrom = `-- name: UpdateOrgsValidFrom :one
UPDATE plan_assignment
SET valid_from = $4,
    updated_by = $3
WHERE plan_id = $1
AND organization_id = $2
RETURNING id, plan_id, organization_id, user_id, valid_from, valid_until, created_at, updated_at, created_by, updated_by
`

type UpdateOrgsValidFromParams struct {
	PlanID         pgtype.UUID
	OrganizationID pgtype.UUID
	UpdatedBy      string
	ValidFrom      pgtype.Timestamptz
}

func (q *Queries) UpdateOrgsValidFrom(ctx context.Context, arg UpdateOrgsValidFromParams) (PlanAssignment, error) {
	row := q.db.QueryRow(ctx, updateOrgsValidFrom,
		arg.PlanID,
		arg.OrganizationID,
		arg.UpdatedBy,
		arg.ValidFrom,
	)
	var i PlanAssignment
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.OrganizationID,
		&i.UserID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const updateOrgsValidUntil = `-- name: UpdateOrgsValidUntil :one
UPDATE plan_assignment
SET valid_until = $4,
    updated_by = $3
WHERE plan_id = $1
AND organization_id = $2
RETURNING id, plan_id, organization_id, user_id, valid_from, valid_until, created_at, updated_at, created_by, updated_by
`

type UpdateOrgsValidUntilParams struct {
	PlanID         pgtype.UUID
	OrganizationID pgtype.UUID
	UpdatedBy      string
	ValidUntil     pgtype.Timestamptz
}

func (q *Queries) UpdateOrgsValidUntil(ctx context.Context, arg UpdateOrgsValidUntilParams) (PlanAssignment, error) {
	row := q.db.QueryRow(ctx, updateOrgsValidUntil,
		arg.PlanID,
		arg.OrganizationID,
		arg.UpdatedBy,
		arg.ValidUntil,
	)
	var i PlanAssignment
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.OrganizationID,
		&i.UserID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const updateUsersValidFrom = `-- name: UpdateUsersValidFrom :one
UPDATE plan_assignment
SET valid_from = $4,
    updated_by = $3
WHERE plan_id = $1
AND user_id = $2
RETURNING id, plan_id, organization_id, user_id, valid_from, valid_until, created_at, updated_at, created_by, updated_by
`

type UpdateUsersValidFromParams struct {
	PlanID    pgtype.UUID
	UserID    pgtype.UUID
	UpdatedBy string
	ValidFrom pgtype.Timestamptz
}

func (q *Queries) UpdateUsersValidFrom(ctx context.Context, arg UpdateUsersValidFromParams) (PlanAssignment, error) {
	row := q.db.QueryRow(ctx, updateUsersValidFrom,
		arg.PlanID,
		arg.UserID,
		arg.UpdatedBy,
		arg.ValidFrom,
	)
	var i PlanAssignment
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.OrganizationID,
		&i.UserID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const updateUsersValidUntil = `-- name: UpdateUsersValidUntil :one
UPDATE plan_assignment
SET valid_until = $4,
    updated_by = $3
WHERE plan_id = $1
AND user_id = $2
RETURNING id, plan_id, organization_id, user_id, valid_from, valid_until, created_at, updated_at, created_by, updated_by
`

type UpdateUsersValidUntilParams struct {
	PlanID     pgtype.UUID
	UserID     pgtype.UUID
	UpdatedBy  string
	ValidUntil pgtype.Timestamptz
}

func (q *Queries) UpdateUsersValidUntil(ctx context.Context, arg UpdateUsersValidUntilParams) (PlanAssignment, error) {
	row := q.db.QueryRow(ctx, updateUsersValidUntil,
		arg.PlanID,
		arg.UserID,
		arg.UpdatedBy,
		arg.ValidUntil,
	)
	var i PlanAssignment
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.OrganizationID,
		&i.UserID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

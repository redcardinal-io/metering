// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: plan_feature.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkPlanAndFeatureForTenant = `-- name: CheckPlanAndFeatureForTenant :one
select exists (
    select 1
    from
        plan p
    join
        feature f on p.tenant_slug = f.tenant_slug 
    where
        p.id = $1
        and f.id = $2
        and p.tenant_slug = $3 
)
`

type CheckPlanAndFeatureForTenantParams struct {
	ID         pgtype.UUID
	ID_2       pgtype.UUID
	TenantSlug string
}

func (q *Queries) CheckPlanAndFeatureForTenant(ctx context.Context, arg CheckPlanAndFeatureForTenantParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkPlanAndFeatureForTenant, arg.ID, arg.ID_2, arg.TenantSlug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createPlanFeature = `-- name: CreatePlanFeature :one
insert into plan_feature (
    plan_id,
    feature_id,
    config,
    created_by,
    updated_by
) values (
    $1,
    $2,
    $3,
    $4,
    $5 
) returning
    id as plan_feature_id,
    plan_id,
    feature_id,
    config,
    created_at,
    updated_at,
    created_by,
    updated_by
`

type CreatePlanFeatureParams struct {
	PlanID    pgtype.UUID
	FeatureID pgtype.UUID
	Config    []byte
	CreatedBy string
	UpdatedBy string
}

type CreatePlanFeatureRow struct {
	PlanFeatureID pgtype.UUID
	PlanID        pgtype.UUID
	FeatureID     pgtype.UUID
	Config        []byte
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	CreatedBy     string
	UpdatedBy     string
}

func (q *Queries) CreatePlanFeature(ctx context.Context, arg CreatePlanFeatureParams) (CreatePlanFeatureRow, error) {
	row := q.db.QueryRow(ctx, createPlanFeature,
		arg.PlanID,
		arg.FeatureID,
		arg.Config,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i CreatePlanFeatureRow
	err := row.Scan(
		&i.PlanFeatureID,
		&i.PlanID,
		&i.FeatureID,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const deletePlanFeature = `-- name: DeletePlanFeature :exec
delete from plan_feature
where plan_id = $1
and feature_id = $2
`

type DeletePlanFeatureParams struct {
	PlanID    pgtype.UUID
	FeatureID pgtype.UUID
}

func (q *Queries) DeletePlanFeature(ctx context.Context, arg DeletePlanFeatureParams) error {
	_, err := q.db.Exec(ctx, deletePlanFeature, arg.PlanID, arg.FeatureID)
	return err
}

const getPlanFeatureIDByPlanAndFeature = `-- name: GetPlanFeatureIDByPlanAndFeature :one
select
    pf.id as plan_feature_id
from
    plan_feature pf
join
    plan p on pf.plan_id = p.id
join
    feature f on pf.feature_id = f.id
where
    p.id = $2::uuid
    and f.id = $3::uuid
    and p.tenant_slug = $1
`

type GetPlanFeatureIDByPlanAndFeatureParams struct {
	TenantSlug string
	PlanID     pgtype.UUID
	FeatureID  pgtype.UUID
}

func (q *Queries) GetPlanFeatureIDByPlanAndFeature(ctx context.Context, arg GetPlanFeatureIDByPlanAndFeatureParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getPlanFeatureIDByPlanAndFeature, arg.TenantSlug, arg.PlanID, arg.FeatureID)
	var plan_feature_id pgtype.UUID
	err := row.Scan(&plan_feature_id)
	return plan_feature_id, err
}

const listPlanFeaturesByPlan = `-- name: ListPlanFeaturesByPlan :many
select
    pf.id as plan_feature_id,
    pf.plan_id,
    pf.feature_id,
    pf.config,
    pf.created_at,
    pf.updated_at,
    pf.created_by,
    pf.updated_by,
    f.name as feature_name,
    f.slug as feature_slug,
    f.description as feature_description,
    f.type as feature_type,
    f.config as feature_config,
    f.tenant_slug as feature_tenant_slug
from 
    plan_feature pf
join
    feature f on pf.feature_id = f.id
where
    pf.plan_id = $1
    and ($2::feature_enum is null or f.type = $2::feature_enum)
order by
    pf.created_at desc
`

type ListPlanFeaturesByPlanParams struct {
	PlanID      pgtype.UUID
	FeatureType NullFeatureEnum
}

type ListPlanFeaturesByPlanRow struct {
	PlanFeatureID      pgtype.UUID
	PlanID             pgtype.UUID
	FeatureID          pgtype.UUID
	Config             []byte
	CreatedAt          pgtype.Timestamptz
	UpdatedAt          pgtype.Timestamptz
	CreatedBy          string
	UpdatedBy          string
	FeatureName        string
	FeatureSlug        string
	FeatureDescription pgtype.Text
	FeatureType        FeatureEnum
	FeatureConfig      []byte
	FeatureTenantSlug  string
}

func (q *Queries) ListPlanFeaturesByPlan(ctx context.Context, arg ListPlanFeaturesByPlanParams) ([]ListPlanFeaturesByPlanRow, error) {
	rows, err := q.db.Query(ctx, listPlanFeaturesByPlan, arg.PlanID, arg.FeatureType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPlanFeaturesByPlanRow
	for rows.Next() {
		var i ListPlanFeaturesByPlanRow
		if err := rows.Scan(
			&i.PlanFeatureID,
			&i.PlanID,
			&i.FeatureID,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.FeatureName,
			&i.FeatureSlug,
			&i.FeatureDescription,
			&i.FeatureType,
			&i.FeatureConfig,
			&i.FeatureTenantSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlanFeatureConfigByPlan = `-- name: UpdatePlanFeatureConfigByPlan :one
update
    plan_feature
set
    config = $1,      
    updated_by = $2  
where
    plan_id = $3      
    and feature_id = $4 
returning
    id AS plan_feature_id,
    plan_id,
    feature_id,
    config,
    created_at,
    updated_at,
    created_by,
    updated_by
`

type UpdatePlanFeatureConfigByPlanParams struct {
	Config    []byte
	UpdatedBy string
	PlanID    pgtype.UUID
	FeatureID pgtype.UUID
}

type UpdatePlanFeatureConfigByPlanRow struct {
	PlanFeatureID pgtype.UUID
	PlanID        pgtype.UUID
	FeatureID     pgtype.UUID
	Config        []byte
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	CreatedBy     string
	UpdatedBy     string
}

func (q *Queries) UpdatePlanFeatureConfigByPlan(ctx context.Context, arg UpdatePlanFeatureConfigByPlanParams) (UpdatePlanFeatureConfigByPlanRow, error) {
	row := q.db.QueryRow(ctx, updatePlanFeatureConfigByPlan,
		arg.Config,
		arg.UpdatedBy,
		arg.PlanID,
		arg.FeatureID,
	)
	var i UpdatePlanFeatureConfigByPlanRow
	err := row.Scan(
		&i.PlanFeatureID,
		&i.PlanID,
		&i.FeatureID,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

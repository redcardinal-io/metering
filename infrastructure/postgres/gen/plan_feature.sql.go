// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: plan_feature.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPlanFeature = `-- name: CreatePlanFeature :one
insert into plan_feature (
    plan_id,
    feature_id,
    config,
    created_by,
    updated_by
) values (
    $1,
    $2,
    $3,
    $4,
    $5 
) returning
    id as plan_feature_id,
    plan_id,
    feature_id,
    config,
    created_at,
    updated_at,
    created_by,
    updated_by
`

type CreatePlanFeatureParams struct {
	PlanID    pgtype.UUID
	FeatureID pgtype.UUID
	Config    []byte
	CreatedBy string
	UpdatedBy string
}

type CreatePlanFeatureRow struct {
	PlanFeatureID pgtype.UUID
	PlanID        pgtype.UUID
	FeatureID     pgtype.UUID
	Config        []byte
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	CreatedBy     string
	UpdatedBy     string
}

func (q *Queries) CreatePlanFeature(ctx context.Context, arg CreatePlanFeatureParams) (CreatePlanFeatureRow, error) {
	row := q.db.QueryRow(ctx, createPlanFeature,
		arg.PlanID,
		arg.FeatureID,
		arg.Config,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i CreatePlanFeatureRow
	err := row.Scan(
		&i.PlanFeatureID,
		&i.PlanID,
		&i.FeatureID,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const deletePlanFeature = `-- name: DeletePlanFeature :exec
delete from plan_feature
where id = $1
and plan_id = $2
and feature_id = $3
`

type DeletePlanFeatureParams struct {
	ID        pgtype.UUID
	PlanID    pgtype.UUID
	FeatureID pgtype.UUID
}

func (q *Queries) DeletePlanFeature(ctx context.Context, arg DeletePlanFeatureParams) error {
	_, err := q.db.Exec(ctx, deletePlanFeature, arg.ID, arg.PlanID, arg.FeatureID)
	return err
}

const listPlanFeaturesByPlan = `-- name: ListPlanFeaturesByPlan :many
select
    pf.id as plan_feature_id,
    pf.plan_id,
    pf.feature_id,
    pf.config,
    pf.created_at,
    pf.updated_at,
    pf.created_by,
    pf.updated_by,
    f.name as feature_name,
    f.slug as feature_slug,
    f.description as feature_description,
    f.type as feature_type,
    f.config as feature_config,
    f.tenant_slug as feature_tenant_slug
from 
    plan_feature pf
join
    feature f on pf.feature_id = f.id
where
    pf.plan_id = $1
    and ($4 is null or f.type = $4)
order by
    pf.created_at desc
limit $2
offset $3
`

type ListPlanFeaturesByPlanParams struct {
	PlanID      pgtype.UUID
	Limit       int32
	Offset      int32
	FeatureType interface{}
}

type ListPlanFeaturesByPlanRow struct {
	PlanFeatureID      pgtype.UUID
	PlanID             pgtype.UUID
	FeatureID          pgtype.UUID
	Config             []byte
	CreatedAt          pgtype.Timestamptz
	UpdatedAt          pgtype.Timestamptz
	CreatedBy          string
	UpdatedBy          string
	FeatureName        string
	FeatureSlug        string
	FeatureDescription pgtype.Text
	FeatureType        FeatureEnum
	FeatureConfig      []byte
	FeatureTenantSlug  string
}

func (q *Queries) ListPlanFeaturesByPlan(ctx context.Context, arg ListPlanFeaturesByPlanParams) ([]ListPlanFeaturesByPlanRow, error) {
	rows, err := q.db.Query(ctx, listPlanFeaturesByPlan,
		arg.PlanID,
		arg.Limit,
		arg.Offset,
		arg.FeatureType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPlanFeaturesByPlanRow
	for rows.Next() {
		var i ListPlanFeaturesByPlanRow
		if err := rows.Scan(
			&i.PlanFeatureID,
			&i.PlanID,
			&i.FeatureID,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.FeatureName,
			&i.FeatureSlug,
			&i.FeatureDescription,
			&i.FeatureType,
			&i.FeatureConfig,
			&i.FeatureTenantSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlanFeatureConfigByPlan = `-- name: UpdatePlanFeatureConfigByPlan :one
update
    plan_feature
set
    config = $1,      
    updated_by = $2  
where
    plan_id = $3      
    and feature_id = $4 
returning
    id AS plan_feature_id,
    plan_id,
    feature_id,
    config,
    created_at,
    updated_at,
    created_by,
    updated_by
`

type UpdatePlanFeatureConfigByPlanParams struct {
	Config    []byte
	UpdatedBy string
	PlanID    pgtype.UUID
	FeatureID pgtype.UUID
}

type UpdatePlanFeatureConfigByPlanRow struct {
	PlanFeatureID pgtype.UUID
	PlanID        pgtype.UUID
	FeatureID     pgtype.UUID
	Config        []byte
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	CreatedBy     string
	UpdatedBy     string
}

func (q *Queries) UpdatePlanFeatureConfigByPlan(ctx context.Context, arg UpdatePlanFeatureConfigByPlanParams) (UpdatePlanFeatureConfigByPlanRow, error) {
	row := q.db.QueryRow(ctx, updatePlanFeatureConfigByPlan,
		arg.Config,
		arg.UpdatedBy,
		arg.PlanID,
		arg.FeatureID,
	)
	var i UpdatePlanFeatureConfigByPlanRow
	err := row.Scan(
		&i.PlanFeatureID,
		&i.PlanID,
		&i.FeatureID,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

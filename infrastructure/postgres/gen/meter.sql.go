// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: meter.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countMeters = `-- name: CountMeters :one
SELECT count(*) FROM meter 
WHERE tenant_slug = $1
and deleted_at IS NULL
`

func (q *Queries) CountMeters(ctx context.Context, tenantSlug string) (int64, error) {
	row := q.db.QueryRow(ctx, countMeters, tenantSlug)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMetersByEventType = `-- name: CountMetersByEventType :one
SELECT count(*) FROM meter
WHERE event_type = $1
AND tenant_slug = $2
AND deleted_at IS NULL
`

type CountMetersByEventTypeParams struct {
	EventType  pgtype.Text
	TenantSlug string
}

func (q *Queries) CountMetersByEventType(ctx context.Context, arg CountMetersByEventTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMetersByEventType, arg.EventType, arg.TenantSlug)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMeter = `-- name: CreateMeter :one
INSERT INTO meter (
    name,
    slug,
    event_type,
    description,
    value_property,
    properties,
    aggregation,
    tenant_slug,
    created_by,
    updated_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, name, slug, event_type, description, value_property, properties, aggregation, created_at, tenant_slug, created_by, updated_by, updated_at
`

type CreateMeterParams struct {
	Name          string
	Slug          string
	EventType     pgtype.Text
	Description   pgtype.Text
	ValueProperty pgtype.Text
	Properties    []string
	Aggregation   AggregationEnum
	TenantSlug    string
  CreatedBy     string
}

func (q *Queries) CreateMeter(ctx context.Context, arg CreateMeterParams) (Meter, error) {
	row := q.db.QueryRow(ctx, createMeter,
		arg.Name,
		arg.Slug,
		arg.EventType,
		arg.Description,
		arg.ValueProperty,
		arg.Properties,
		arg.Aggregation,
		arg.TenantSlug,
    arg.CreatedBy,
    arg.CreatedBy,
	)
	var i Meter
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.EventType,
		&i.Description,
		&i.ValueProperty,
		&i.Properties,
		&i.Aggregation,
		&i.CreatedAt,
		&i.TenantSlug,
    &i.CreatedBy,
    &i.UpdatedBy,
    &i.UpdatedAt,
	)
	return i, err
}

const deleteMeterByID = `-- name: DeleteMeterByID :exec
UPDATE meter
SET deleted_at = CURRENT_TIMESTAMP 
WHERE id = $1 
AND tenant_slug = $2
`

type DeleteMeterByIDParams struct {
	ID         pgtype.UUID
	TenantSlug string
}

func (q *Queries) DeleteMeterByID(ctx context.Context, arg DeleteMeterByIDParams) error {
	_, err := q.db.Exec(ctx, deleteMeterByID, arg.ID, arg.TenantSlug)
	return err
}

const deleteMeterBySlug = `-- name: DeleteMeterBySlug :exec
UPDATE meter
SET deleted_at = CURRENT_TIMESTAMP
WHERE slug = $1
AND tenant_slug = $2
`

type DeleteMeterBySlugParams struct {
	Slug       string
	TenantSlug string
}

func (q *Queries) DeleteMeterBySlug(ctx context.Context, arg DeleteMeterBySlugParams) error {
	_, err := q.db.Exec(ctx, deleteMeterBySlug, arg.Slug, arg.TenantSlug)
	return err
}

const getMeterByID = `-- name: GetMeterByID :one
SELECT id, name, slug, event_type, description, value_property, properties, aggregation, created_at, tenant_slug, created_by, updated_by, updated_at FROM meter
WHERE id = $1
AND tenant_slug = $2
AND deleted_at IS NULL
`

type GetMeterByIDParams struct {
	ID         pgtype.UUID
	TenantSlug string
}

func (q *Queries) GetMeterByID(ctx context.Context, arg GetMeterByIDParams) (Meter, error) {
	row := q.db.QueryRow(ctx, getMeterByID, arg.ID, arg.TenantSlug)
	var i Meter
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.EventType,
		&i.Description,
		&i.ValueProperty,
		&i.Properties,
		&i.Aggregation,
		&i.CreatedAt,
		&i.TenantSlug,
    &i.CreatedBy,
    &i.UpdatedBy,
    &i.UpdatedAt,
	)
	return i, err
}

const getMeterBySlug = `-- name: GetMeterBySlug :one
SELECT id, name, slug, event_type, description, value_property, properties, aggregation, created_at, tenant_slug, created_by, updated_by, updated_at FROM meter
WHERE slug = $1
AND tenant_slug = $2
AND deleted_at IS NULL
`

type GetMeterBySlugParams struct {
	Slug       string
	TenantSlug string
}

func (q *Queries) GetMeterBySlug(ctx context.Context, arg GetMeterBySlugParams) (Meter, error) {
	row := q.db.QueryRow(ctx, getMeterBySlug, arg.Slug, arg.TenantSlug)
	var i Meter
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.EventType,
		&i.Description,
		&i.ValueProperty,
		&i.Properties,
		&i.Aggregation,
		&i.CreatedAt,
		&i.TenantSlug,
    &i.CreatedBy,
    &i.UpdatedBy,
    &i.UpdatedAt,
	)
	return i, err
}

const getPropertiesByEventType = `-- name: GetPropertiesByEventType :many
SELECT DISTINCT unnest(properties) as property 
FROM meter
WHERE event_type = $1
AND tenant_slug = $2
ORDER BY property
`

type GetPropertiesByEventTypeParams struct {
	EventType  pgtype.Text
	TenantSlug string
}

func (q *Queries) GetPropertiesByEventType(ctx context.Context, arg GetPropertiesByEventTypeParams) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, getPropertiesByEventType, arg.EventType, arg.TenantSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var property interface{}
		if err := rows.Scan(&property); err != nil {
			return nil, err
		}
		items = append(items, property)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValuePropertiesByEventType = `-- name: GetValuePropertiesByEventType :many
SELECT DISTINCT value_property FROM meter
WHERE event_type = $1 AND value_property IS NOT NULL
AND tenant_slug = $2
ORDER BY value_property
`

type GetValuePropertiesByEventTypeParams struct {
	EventType  pgtype.Text
	TenantSlug string
}

func (q *Queries) GetValuePropertiesByEventType(ctx context.Context, arg GetValuePropertiesByEventTypeParams) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, getValuePropertiesByEventType, arg.EventType, arg.TenantSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var value_property pgtype.Text
		if err := rows.Scan(&value_property); err != nil {
			return nil, err
		}
		items = append(items, value_property)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMetersByEventTypes = `-- name: ListMetersByEventTypes :many
SELECT id, name, slug, event_type, description, value_property, properties, aggregation, created_at, tenant_slug, created_by, updated_by, updated_at FROM meter
WHERE event_type = ANY($1::text[])
AND tenant_slug = $2
AND deleted_at IS NULL
`

type ListMetersByEventTypesParams struct {
	Column1    []string
	TenantSlug string
}

func (q *Queries) ListMetersByEventTypes(ctx context.Context, arg ListMetersByEventTypesParams) ([]Meter, error) {
	rows, err := q.db.Query(ctx, listMetersByEventTypes, arg.Column1, arg.TenantSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meter
	for rows.Next() {
		var i Meter
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.EventType,
			&i.Description,
			&i.ValueProperty,
			&i.Properties,
			&i.Aggregation,
			&i.CreatedAt,
			&i.TenantSlug,
      &i.CreatedBy,
      &i.UpdatedBy,
      &i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMetersPaginated = `-- name: ListMetersPaginated :many
SELECT id, name, slug, event_type, description, value_property, properties, aggregation, created_at, tenant_slug, created_by, updated_by, updated_at FROM meter
WHERE tenant_slug = $1
AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type ListMetersPaginatedParams struct {
	TenantSlug string
	Limit      int32
	Offset     int32
}

func (q *Queries) ListMetersPaginated(ctx context.Context, arg ListMetersPaginatedParams) ([]Meter, error) {
	rows, err := q.db.Query(ctx, listMetersPaginated, arg.TenantSlug, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meter
	for rows.Next() {
		var i Meter
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.EventType,
			&i.Description,
			&i.ValueProperty,
			&i.Properties,
			&i.Aggregation,
			&i.CreatedAt,
			&i.TenantSlug,
      &i.CreatedBy,
      &i.UpdatedBy,
      &i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMeterByID = `-- name: UpdateMeterByID :one
UPDATE meter
SET name = CASE WHEN $1::text = '' THEN name ELSE $1::text END,
    description = coalesce($2, description),
    updated_by = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $3
AND tenant_slug = $4
RETURNING id, name, slug, event_type, description, value_property, properties, aggregation, created_at, tenant_slug, created_by, updated_by, updated_at
`

type UpdateMeterByIDParams struct {
	Column1     string
	Description pgtype.Text
	ID          pgtype.UUID
	TenantSlug  string
  UpdatedBy   string
}

func (q *Queries) UpdateMeterByID(ctx context.Context, arg UpdateMeterByIDParams) (Meter, error) {
	row := q.db.QueryRow(ctx, updateMeterByID,
		arg.Column1,
		arg.Description,
		arg.ID,
		arg.TenantSlug,
    arg.UpdatedBy,
	)
	var i Meter
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.EventType,
		&i.Description,
		&i.ValueProperty,
		&i.Properties,
		&i.Aggregation,
		&i.CreatedAt,
		&i.TenantSlug,
    &i.CreatedBy,
    &i.UpdatedBy,
    &i.UpdatedAt,
	)
	return i, err
}

const updateMeterBySlug = `-- name: UpdateMeterBySlug :one
UPDATE meter
SET name = CASE WHEN $1::text = '' THEN name ELSE $1::text END,
    description = coalesce($2, description),
    updated_by = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE slug = $3
AND tenant_slug = $4
RETURNING id, name, slug, event_type, description, value_property, properties, aggregation, created_at, tenant_slug, created_by, updated_by, updated_at
`

type UpdateMeterBySlugParams struct {
	Column1     string
	Description pgtype.Text
	Slug        string
	TenantSlug  string
  UpdatedBy   string
}

func (q *Queries) UpdateMeterBySlug(ctx context.Context, arg UpdateMeterBySlugParams) (Meter, error) {
	row := q.db.QueryRow(ctx, updateMeterBySlug,
		arg.Column1,
		arg.Description,
		arg.Slug,
		arg.TenantSlug,
    arg.UpdatedBy,
	)
	var i Meter
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.EventType,
		&i.Description,
		&i.ValueProperty,
		&i.Properties,
		&i.Aggregation,
		&i.CreatedAt,
		&i.TenantSlug,
    &i.CreatedBy,
    &i.UpdatedBy,
    &i.UpdatedAt,
	)
	return i, err
}
